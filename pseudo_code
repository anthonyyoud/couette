couette_mod.f90
---------------
* Initialise ScaLAPACK process grid.
* Open runtime files --> open_files(), io.f90.
* Set up finite-difference mesh --> get_xzs(), ic_bc.f90.
* Set up initial conditions --> ICS(), ic_bc.f90.
* Test to see if end_state.dat exists when it shouldn't.
* Set up boundary conditions if not doing restart --> *_BCS(), ic_bc.f90.
* Allocate matrix dimensions local to each ScaLAPACK process, depending on tau.
* Set up matrices for azimuthal velocity, vorticity --> matrix_setup(),
  matrices.f90.
* Set up matrices for stream function, azimuthal magnetic field/current -->
  *_mat_setup(), matrices.f90.
* Initialise all variables to 'new' --> copy_var(), variables.f90.
* Start time loop.
  * Terminate if 'RUNNING' doesn't exist --> terminate(), io.f90.
  * Save fields if 'SAVE' exists --> save_run(), io.f90.
  * Write data to files --> write_data(), io.f90.
  * Increment time.
  * Update variables --> copy_var(), variables.f90.
  * Save cross-sections --> xsect_save(), io.f90.
  * Save 3D isosurface --> save_3d() io.f90.
  * Update variables --> copy_var(), variables.f90.
  * Get the linear parts of the RHS for the solution of the azimuthal velocity
    --> get_rhs_ux(), linear.f90.
  * Get the nonlinear parts of the RHS for the solution of the azimuthal
    velocity --> get_nlin_ux(), nonlinear.f90.
  * Get the linear parts of the RHS for the solution of the azimuthal vorticity
    --> get_rhs_Zx(), linear.f90.
  * Get the nonlinear parts of the RHS for the solution of the azimuthal
    vorticity --> get_nlin_Zx(), nonlinear.f90.
  * Solve for the azimuthal velocity in the radial direction --> solve_ux(),
    solve.f90.
  * Solve for the azimuthal vorticity in the radial direction --> solve_Zx(),
    solve.f90.
  * Update intermediate variables --> copy_var(), variables.f90.
  * Solve for the azimuthal velocity in the axial direction --> solve_uz(),
    solve.f90.
  * Solve for the azimuthal vorticity in the axial direction --> solve_Zz(),
    solve.f90.
  * Update final variables --> copy_var(), variables.f90.
  * Update Poisson boundary conditions --> *_BCS(), ic_bc.f90.
  * Broadcast azimuthal velocity/vorticity to other processes for use in
    Poisson equations.
  * Solve Poisson equations for stream function, azimuthal magnetic
    field/current depending on tau --> p_poisson(), stream.f90; *_b_poisson(),
    magnetic.f90; *_j_poisson(), current.f90.
  * Update variables --> copy_var(), variables.f90.
  * If final time save the current state --> end_state(), io.f90.
* End time loop.
* Deallocate allocated arrays.
* Close runtime files --> close_files(), io.f90.
* Release ScaLAPACK process grid.

current.f90
-----------
* SUBROUTINE j_poisson()
* Solve Poisson equation for the azimuthal current when tau/=1.
  * Set up ScaLAPACK descriptor vector.
  * Get derivatives --> deriv_*(), derivs.f90.
  * Broadcast RHS to all processes.
  * Distribute RHS as a vector over the process grid, in block column format.
  * Solve Poisson equation via ScaLAPACK routine P*DBTRS.
  * Transform distributed RHS vector into distributed matrix.
  * Collect distributed matrix onto master process.
  * Update boundary conditions --> j_BCS(), ic_bc.f90.

* SUBROUTINE fin_j_poisson()
* Solve Poisson equation for the azimuthal current when tau=1.
  * Algorithm as for j_poisson().

derivs.f90
----------
* SUBROUTINE deriv_x()
* First x derivative.
  * Calculate centred finite-difference derivative.

* SUBROUTINE deriv_xx()
* Second x derivative.
  * As for deriv_x().

* SUBROUTINE deriv_z()
* First z derivative.
  * As for deriv_x() with additional forward/backward difference at boundaries.

* SUBROUTINE deriv_zz()
* Second z derivative.
  * As for deriv_z().

ic_bc.f90
---------
* SUBROUTINE get_xzs()
* Finite-difference mesh.
  * Set up mesh.

* SUBROUTINE ICS()
* Initial conditions.
  * If doing a restart get restart conditions --> state_restart(), ic_bc.f90.
  * If not doing a restart set up the initial condition.

* SUBROUTINE state_restart()
* Get restart data.
  * Read previous run's data.
  * If mesh size is not the same as previous run interpolate onto new grid -->
    inter(), ic_bc.f90.
  * If time-step is not the same as previous run adjust time index.

* SUBROUTINE inter()
* Interpolate onto a new grid.
  * Set up a mesh using the previous run's mesh size.
  * Interpolate --> inter_var(), ic_bc.f90.

* SUBROUTINE inter_var()
* Bilinear interpolation, Numerical Recipes in Fortran77 Chap. 3.6 p.116.

* SUBROUTINE *_BCS()
* Boundary conditions.

io.f90
------
* FUNCTION itos()
* Convert an integer to a string.

* SUBROUTINE open_files()
* Open runtime files.

* SUBROUTINE close_files()
* Close runtime files.

* SUBROUTINE save_growth()
* Save fields at particular points in (r,z)-plane.
  * Calculate the growth rate of vortices.
  * Write particular point of fields to file.
  * Calculate maximum/minimum of fields.

* SUBROUTINE save_torque()
* Save torques on inner/outer cylinders.

* SUBROUTINE get_CCF()
* Get the (dimensionless) circular Couette flow.

* SUBROUTINE save_xsect()
* Save cross-sections of fields for use in IDL.

* SUBROUTINE save_3d()
* Save 3D isosurface for use in OpenDX.
  * If a helicity isosurface is desired calculate helicity --> helicity(),
    io.f90.
  * Write the helicity or stream function in cylindrical coordinates.

* SUBROUTINE helicity()
* Calculate helicity u.(curl u).

* SUBROUTINE save_surface()
* Save surfaces of fields for use in gnuplot.

* SUBROUTINE write_data()
* Calculations of various quantities; save fields.
  * Get radial/axial velocities --> vr_vz(), variables.f90.
  * Save a particle path if desired --> particle(), io.f90.
  * Save the torque --> save_torque(), io.f90.
  * Save growth rates, points of fields --> save_growth(), io.f90.
  * Save the kinetic energy --> save_energy(), io.f90.
  * Increment tau if auto_tau is enabled.
  * End the run if the flow has saturated --> end_state(), io.f90.

* SUBROUTINE terminate()
* End the run if 'RUNNING' does not exist in run directory.

* SUBROUTINE save_run()
* Save cross-sections, surfaces if file 'SAVE' exists in run directory.

* SUBROUTINE end_state()
* Save variables for use in a restarted run.

* SUBROUTINE save_time_tau()
* Save the times at which tau is incremented.

* SUBROUTINE particle()
* Calculate and save a particle path (basic).

* SUBROUTINE energy_CCF()
* Explicitly integrated (dimensionless) form of the kinetic energy in CCF.

* SUBROUTINE save_energy()
* Total kinetic energy in flow (including CCF).
  * Get the energy in the underlying CCF
  * Integrate in r --> integrate_r(), variables.f90.
  * Integrate in z --> integrate_z(), variables.f90.
  * Write energies.

linear.f90
----------
* SUBROUTINE get_rhs_ux()
* Get the linear part for the RHS of the tridiagonal system for the azimuthal
  velocity.
  * Get derivatives --> deriv_*(), derivs.f90.
  * Get the linear parts of the RHS depending on tau.

* SUBROUTINE get_rhs_Zx()
* Get the linear part for the RHS of the tridiagonal system for the azimuthal
  vorticity.
  * Get derivatives --> deriv_*(), derivs.f90.
  * Get the linear parts of the RHS.

magnetic.f90
------------
* SUBROUTINE b_poisson()
* Solve Poisson equation for azimuthal magnetic field when tau=0.
  * Algorithms for the solution of the magnetic Poisson equation are as
    for the current in current.f90.

matrices.f90
------------
* SUBROUTINE matrix_setup()
* Set up the upper, lower and diagonal parts of the tridiagonal matrices
  for the solution of the azimuthal velocity and vorticity equations.
  * Get the lower-diagonal, diagonal and upper-diagonal elements from the LHS
    matrices in the radial and axial directions.
  * Get extra entries due to Neumann boundary conditions at cylinder ends when
    tau=1.

* SUBROUTINE psi_mat_setup()
* Setup of LHS matrix in solution of stream function Poisson equation.
  * Get the coefficients in the banded matrix.
  * Set up the ScaLAPACK descriptor vector.
  * Distribute the matrix over the process grid using the block-column
    distribution for banded matrices.
  * Do an LU factorisation via ScaLAPACK routine P*DBTRF.

* SUBROUTINE (fin_)b_mat_setup()
* Setup of LHS matrix in solution of magnetic Poisson equation (depending on
  tau).
  * Algorithm as in psi_mat_setup().

* SUBROUTINE (fin_)j_mat_setup()
* Setup of LHS matrix in solution of current Poisson equation (depending on
  tau).
  * Algorithm as in psi_mat_setup().

nonlinear.f90
-------------
* SUBROUTINE get_nlin_ux()
* Get nonlinear part for the RHS of the tridiagonal system for the azimuthal
  velocity.
  * Get derivatives --> deriv_*(), derivs.f90.
  * Get the nonlinear parts of the RHS depending on tau.

* SUBROUTINE get_nlin_Zx()
* Get nonlinear part for the RHS of the tridiagonal system for the azimuthal
  vorticity.
  * Get derivatives --> deriv_*(), derivs.f90.
  * Get the nonlinear parts of the RHS depending on tau.

parameters.f90
--------------
* Set up all parameters related to the code.

solve.f90
---------
* SUBROUTINE solve_ux()
* Solve for the (intermediate) azimuthal velocity field in the radial
  direction.
  * Update the boundary conditions --> u_BCS(), ic_bc.f90.
  * Put together the linear and nonlinear parts as a vector at a fixed axial
    position.
  * Update entries for boundary conditions.
  * Solve for the intermediate solution at each axial position using the Thomas
    algorithm.
  * Solve for extra entries if tau=1.

* SUBROUTINE solve_Zx()
* Solve for the (intermediate) azimuthal vorticity field in the radial
  direction.
  * Update the boundary conditions --> z_BCS(), ic_bc.f90.
  * Put together the linear and nonlinear parts as a vector at a fixed axial
    position.
  * Update entries for boundary conditions.
  * Solve for the intermediate solution at each axial position using the Thomas
    algorithm.

* SUBROUTINE solve_uz()
* Solve for the (full) azimuthal velocity field in the axial direction.
  * Update the boundary conditions --> u_BCS(), ic_bc.f90.
  * Alter the dimensions of the lower-diagonal, diagonal and upper-diagonal
    vectors if tau=1.
  * Put together the intermediate solution as a vector at a fixed radial
    position.
  * Update entries for boundary conditions.
  * Solve for the full solution at each axial position using the Thomas
    algorithm.
  * No extra entries for boundary conditions if tau/=1.

* SUBROUTINE solve_Zz()
* Solve for the (full) azimuthal vorticity field in the axial direction.
  * Update the boundary conditions --> z_BCS(), ic_bc.f90.
  * Put together the intermediate solution as a vector at a fixed radial
    position.
  * Update entries for boundary conditions.
  * Solve for the full solution at each axial position using the Thomas
  * algorithm.

* SUBROUTINE thomas()
* The Thomas algorithm for the solution of a tridiagonal system of equations.
  * Create a new diagonal vector so as not to destroy the original.
  * Eliminate the lower-diagonal elements.
  * Solve by back-substitution.

stream.f90
----------
* SUBROUTINE p_poisson()
* Solve Poisson equation for the stream function for all tau.
  * Algorithms for the solution of the stream function Poisson equation are as
    for the current in current.f90.

variables.f90
-------------
* Set up variable types.
* Set up derivative types.
* Set up matrix component types.

* SUBROUTINE copy_var()
* Copy a variable.

* SUBROUTINE vr_vz()
* Calculate radial and axial velocity components from the stream function.

* SUBROUTINE integrate_r()
* Integrate a (2D) variable in r.

* SUBROUTINE integrate_z()
* Integrate a (1D) variable in z.

* FUNCTION Re_i()
* Time-dependent Reynolds number of the inner (i=1) and outer (i=2) cylinders.
